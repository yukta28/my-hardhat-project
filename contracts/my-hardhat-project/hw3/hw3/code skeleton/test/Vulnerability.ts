import { time, loadFixture } from "@nomicfoundation/hardhat-network-helpers";
import { anyValue } from "@nomicfoundation/hardhat-chai-matchers/withArgs";
import { expect } from "chai";
import { ethers } from "hardhat";


describe("Auction", function () {
    async function deployAuctionContract() {
        // Contracts are deployed using the first signer/account by default
        const [owner, otherAccount] = await ethers.getSigners();

        const Vulnerability = await ethers.getContractFactory("Vulnerability");
        const contract = await Vulnerability.deploy();

        console.log(contract.address);
        console.log();

        const Exploit = await ethers.getContractFactory("VulnerabilityExploit");
        const exploitContract = await Exploit.deploy({ value: ethers.utils.parseEther("0.001") });

        return { contract, owner, otherAccount, exploitContract };
    }

    describe("Vulnerability", function () {
        it("Contract should not be vulnerable", async function () {
            const { contract, owner, otherAccount, exploitContract } = await loadFixture(deployAuctionContract);

            const signers = await ethers.getSigners();

            for (let i = 0; i < 5; i++) {
                await contract.connect(owner).deposit(owner.address, { value: ethers.utils.parseEther("0.001") });
            }

            let contractBalance = await exploitContract.getBalance(contract.address);



            await exploitContract.connect(otherAccount).deposit(exploitContract.address, { value: ethers.utils.parseEther("0.001") });
            // console.log("malicious exploiter deposited 0.001 ether");
            console.log("normal users deposited 0.005 ether to the contract");
            console.log("malicious exploiter deposited 0.001 ether to the contract");



            // console.log("the contract's balance is currently " + ethers.utils.formatEther(contractBalance) + " ether");


            contractBalance = await exploitContract.getBalance(contract.address);
            console.log("the contract's balance is now " + ethers.utils.formatEther(contractBalance) + " ether");
            console.log();
            console.log("exploiter is now going to attempt to exploit and withdraw all funds")
            await exploitContract.withdraw();
            console.log();

            contractBalance = await exploitContract.getBalance(contract.address);
            console.log("the contract's balance is now " + ethers.utils.formatEther(contractBalance) + " ether");

            if (contractBalance.toNumber() == 0) {
                console.log("the contract is now empty! the exploiter stole all funds...");
                //fail the test

            } else {
                console.log("congrats! the exploiter failed to steal the funds!");
                //pass the test
            }

            expect(ethers.utils.formatEther(contractBalance).toString(), 'Contract balance should be 0.005 ether after the exploiter withdraws 0.001 ether').to.equal('0.005');
        });
    });
});
